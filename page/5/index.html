<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="zoeee">
<meta property="og:type" content="website">
<meta property="og:title" content="ZY">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="ZY">
<meta property="og:description" content="zoeee">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zhang Yin">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ZY</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZY</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">My Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Yin"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Zhang Yin</p>
  <div class="site-description" itemprop="description">zoeee</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Zooeeee" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zooeeee" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/594498431@qq.com" title="E-Mail → 594498431@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://hexo.io/zh-cn/docs/configuration" title="https:&#x2F;&#x2F;hexo.io&#x2F;zh-cn&#x2F;docs&#x2F;configuration" rel="noopener" target="_blank">Hexo</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://theme-next.iissnan.com/getting-started.html" title="http:&#x2F;&#x2F;theme-next.iissnan.com&#x2F;getting-started.html" rel="noopener" target="_blank">Next</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhang Yin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZY">
      <meta itemprop="description" content="zoeee">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZY">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/19/" class="post-title-link" itemprop="url">一些基础知识1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-19 19:22:44" itemprop="dateCreated datePublished" datetime="2020-04-19T19:22:44+08:00">2020-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-22 22:20:23" itemprop="dateModified" datetime="2020-04-22T22:20:23+08:00">2020-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/css/" itemprop="url" rel="index"><span itemprop="name">css</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="边框实现三角形"><a href="#边框实现三角形" class="headerlink" title="边框实现三角形"></a>边框实现三角形</h4><p>把div的width和height置为0,利用四分之一的border来做成三角形的效果,另外三个三角形通过将颜色置为透明实现</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-top-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border-top-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-top-width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">border-left-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border-left-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-left-width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">border-right-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border-right-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-right-width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>: red;</span><br><span class="line">  <span class="attribute">border-bottom-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-bottom-width</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/04/19/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhang Yin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZY">
      <meta itemprop="description" content="zoeee">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZY">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/18/" class="post-title-link" itemprop="url">js高级程序设计第十一天</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-18 21:22:44" itemprop="dateCreated datePublished" datetime="2020-04-18T21:22:44+08:00">2020-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-28 19:35:00" itemprop="dateModified" datetime="2020-04-28T19:35:00+08:00">2020-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Js/" itemprop="url" rel="index"><span itemprop="name">Js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>如前所述，js中是没有块级作用域这个概念的。但可以使用如下方式实现块级作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  //代码</span><br><span class="line">  alert(&quot;aaa&quot;);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>而不是这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;</span><br><span class="line">  //代码</span><br><span class="line">  alert(&quot;aaa&quot;);</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>两者区别在于这个function声明前后的括号。如果没有，js会把function关键字当作一个函数声明的开始，但是不能接括号。而用一对括号包裹起来后转换成函数表达式则可以接一对括号。</p>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><blockquote>
<p>任何在函数中定义的变量，都可以认为是私有变量。</p>
</blockquote>
<ul>
<li>特权方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function MyObject()&#123;</span><br><span class="line">  //private</span><br><span class="line">  var privateVariable = 10 ;</span><br><span class="line"></span><br><span class="line">  function privateFunction()&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  //特权方法</span><br><span class="line">  this.publicMethod = function()&#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    return privateFunction();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var myObject = new MyObject();</span><br><span class="line">console.log(myObject.privateVariable) ; //undefined</span><br><span class="line">myObject.publicMethod();//false</span><br><span class="line">//以上原因是因为privateVariable和privateFunction没有用this与函数进行绑定，所以这两个值只能在函数内部使用。</span><br><span class="line">//但是也有问题就是每次创建对象都会创建一个相同的变量和方法，浪费空间</span><br></pre></td></tr></table></figure></li>
<li>静态私有变量<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  //private</span><br><span class="line">  var privateVariable = 10 ;</span><br><span class="line"></span><br><span class="line">  function privateFunction()&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //构造函数</span><br><span class="line">  MyObject = function()&#123;&#125;;//初始化未经声明的变量，总会创建一个全局变量</span><br><span class="line"></span><br><span class="line">  //公有or特权方法</span><br><span class="line">  MyObject.prototype.publicMethod = function()&#123;</span><br><span class="line">    privateVariable++;</span><br><span class="line">    return privateFunction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
以上将共用方法定义在原型上，所以所有实例都使用一个函数，结果就是一个实例的使用会造成所有实例的值受到影响。即有一个公有的变量，但是没有实例自己的私有变量。<h3 id="块级模式"><a href="#块级模式" class="headerlink" title="块级模式"></a>块级模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var singleton = function()&#123;</span><br><span class="line">  //private</span><br><span class="line">  var privateVariable = 10 ;</span><br><span class="line"></span><br><span class="line">  function privateFunction()&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //public</span><br><span class="line">  return &#123;</span><br><span class="line">    publicProperty : true ,</span><br><span class="line"></span><br><span class="line">    publicMethod : function()&#123;</span><br><span class="line">      privateVariable++;</span><br><span class="line">      return privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
这个模块模式将一个对象字面量作为函数的值返回，返回的对象字面量中只包含公有的属性和方法。由于这个对象十在匿名函数内部定义的，因此他的公有方法有权访问这些变量。这种模式在需要对单例进行初始化的时候，同时又需要维护其私有变量时非常有用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var application = function()&#123;</span><br><span class="line">  //private</span><br><span class="line">  var components = new Array(); </span><br><span class="line">  </span><br><span class="line">  //初始化</span><br><span class="line">  components.push(new BaseComponent());</span><br><span class="line"></span><br><span class="line">  //public</span><br><span class="line">  return &#123;</span><br><span class="line">    getComponentsCount : function()&#123;</span><br><span class="line">      return components.length;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    registerComponents : function(component)&#123;</span><br><span class="line">      if (typeof component == &quot;object&quot;)&#123;</span><br><span class="line">        components.push(component)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在web应用程序中，常常使用一个单例来管理应用程序级的信息。该公共方法中前者返回已注册的组建数目，后者用于注册组件。<h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var singleton = function()&#123;</span><br><span class="line">  //private</span><br><span class="line">  var privateVariable = 10 ;</span><br><span class="line"></span><br><span class="line">  function privateFunction()&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //创建对象</span><br><span class="line">  var object = new CustomType();</span><br><span class="line"></span><br><span class="line">  //public</span><br><span class="line">  object.publicProperty = true ;</span><br><span class="line">  object.publicMethod = function()&#123;</span><br><span class="line">      privateVariable++;</span><br><span class="line">      return privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  return object;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还得添加某些属性或者方法的情况。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhang Yin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZY">
      <meta itemprop="description" content="zoeee">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZY">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/18/" class="post-title-link" itemprop="url">js高级程序设计第十天</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-18 20:22:44" itemprop="dateCreated datePublished" datetime="2020-04-18T20:22:44+08:00">2020-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-28 19:34:54" itemprop="dateModified" datetime="2020-04-28T19:34:54+08:00">2020-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Js/" itemprop="url" rel="index"><span itemprop="name">Js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h3><ul>
<li>在全局函数中，this指向window。</li>
<li>当函数作为某个对象的方法调用时，指向那个对象。</li>
<li>匿名函数执行对象有全局性，其this对象指向window。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var object = &#123;</span><br><span class="line">  name : &quot;my object&quot;,</span><br><span class="line">  getName : function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">      return this.name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(object.getName()());// window</span><br></pre></td></tr></table></figure>
此处的对象方法只搜索到活动对象为止，不可能直接访问外部函数的变量。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var object = &#123;</span><br><span class="line">  name : &quot;my object&quot;,</span><br><span class="line">  getName : function()&#123;</span><br><span class="line">    var that = this ; //函数返回后，that依然引用着object</span><br><span class="line">    return function()&#123;</span><br><span class="line">      return that.name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(object.getName()());// my object</span><br></pre></td></tr></table></figure></li>
<li><em>几种特殊情况</em>*<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line">var object = &#123;</span><br><span class="line">  name : &quot;my object&quot;,</span><br><span class="line">  getName : function()&#123;</span><br><span class="line">    return this.name   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(object.getName());// my object</span><br></pre></td></tr></table></figure>
还有几种结果</li>
<li>object.getName(); // my object</li>
<li>(object.getName)();// my object</li>
<li>(object.getName = object.getName)() // window</li>
</ul>
<p>解释：</p>
<ul>
<li>this.name 就是object.name</li>
<li>在调用方法前加上括号,就好像只是引用一个函数,但this 的值得到了位置</li>
<li>这个赋值表达式的值时函数本身,所以this 的值不能得到维持,所以返回window.name</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhang Yin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZY">
      <meta itemprop="description" content="zoeee">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZY">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/18/" class="post-title-link" itemprop="url">Word power made easy 章节在线思维导图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-18 19:22:44" itemprop="dateCreated datePublished" datetime="2020-04-18T19:22:44+08:00">2020-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-19 15:53:17" itemprop="dateModified" datetime="2020-04-19T15:53:17+08:00">2020-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/English/" itemprop="url" rel="index"><span itemprop="name">English</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/English/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="word-power-made-easy-章节在线思维导图"><a href="#word-power-made-easy-章节在线思维导图" class="headerlink" title="word power made easy 章节在线思维导图"></a>word power made easy 章节在线思维导图</h4><p><a target="_blank" rel="noopener" href="https://hanxiaomax.github.io/WordPowerMadeEasy/wpme/">github思维导图</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhang Yin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZY">
      <meta itemprop="description" content="zoeee">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZY">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/18/" class="post-title-link" itemprop="url">js高级程序设计第九天</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-18 19:22:44" itemprop="dateCreated datePublished" datetime="2020-04-18T19:22:44+08:00">2020-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-19 15:52:46" itemprop="dateModified" datetime="2020-04-19T15:52:46+08:00">2020-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Js/" itemprop="url" rel="index"><span itemprop="name">Js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。  </p>
</blockquote>
<p>创建闭包的常用方式就是在一个函数内部创建另一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function createComparisonFunction(propertyName)&#123;</span><br><span class="line">  return function(object1 , object2)&#123;</span><br><span class="line">    var value1 = object1[propertyName]; //重点</span><br><span class="line">    var value2 = object2[propertyName]; //重点</span><br><span class="line"></span><br><span class="line">    if(value1 &lt; value2)&#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (value1 &gt; value2)&#123;</span><br><span class="line">      return 1 ;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      return 0 ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，两行代码访问了外部函数的变量propertyName，即使这个内部函数被返回了，而且在其他地方被调用了，但它仍然可以访问变量propertyName。之所以还能访问，是因为内部函数的作用域链中包含createComparisonFunction（）的作用于。</p>
<blockquote>
<p>当某个函数第一次被调用时，会创建一个执行环境（execution context）和相应的作用域链，并把作用域链赋值给一个特殊的内部属性（[Scope]）。然后，使用this，arguments和其他命名参数的值来初始化函数的活动对象（activation object）。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/10/28/ex89GIpWUjowdzc.png" alt="compare作用域链"></p>
<blockquote>
<p>显然作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p>
</blockquote>
<p>无论什么时候在汉书中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域。</p>
<blockquote>
<p>在另一个函数内部定义的函数会将包含函数（外部函数）的活动对象添加到他的作用域链中。因此，在createComparisonFunction函数内部定义的匿名函数的作用域链中，实际上会包含外部函数createComparisonFunction的活动对象。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var compare = createComparisonFunction(&quot;name&quot;);</span><br><span class="line">var result = compare(&#123;name:&quot;zy&quot;&#125;,&#123;name:&quot;zoe&quot;&#125;);</span><br></pre></td></tr></table></figure>
<p>在匿名函数从createComparisonFunction中被返回后，它的作用域链被初始化为包含createComparisonFunction函数的活动对象和全局变量对象。这样，匿名函数就可以访问createComparisonFunction中定义的所有变量。更重要的是<strong>createComparisonFunction函数执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。</strong>换句话说，在createComparisonFunction函数返回有，其执行环境的作用域链会被销毁，但其活动对象仍然会在内存中，直到匿名函数被销毁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compare = null//销毁函数，释放内存</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/10/28/MI54LeQ37SpP98m.png" alt="compare和匿名函数作用域链"></p>
<h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包函数只能取得包含函数中任何变量的最后一个之。别忘了闭包所保存的是整个边栏搞对象，而不是某个特殊的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function createFunction()&#123;</span><br><span class="line">  var result = new Array();</span><br><span class="line"></span><br><span class="line">  for(var i = 0 ; i &lt; 10 ; i ++)&#123;</span><br><span class="line">    result[i] = function()&#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">      return i ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返回自己的所引致，即位置0的函数返回0。实际上，每个函数都返回10。因为每个函数的u总用于联众都保存着createFunction的活动对象，它们引用的都是同一个变量i。但是我们可以通过创建另一个匿名函数强制让闭包的规则符合预期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createFunction()&#123;</span><br><span class="line">  var result = new Array();</span><br><span class="line"></span><br><span class="line">  for(var i = 0 ; i &lt;10 ; i++)&#123;</span><br><span class="line">    result[i] = function(num)&#123;</span><br><span class="line">      return function(num)&#123;</span><br><span class="line">        return num;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个版本中，我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋值给数组。在调用每个匿名函数是，我们传入了变量i。由于函数参数是值传递，所以会将变量i的当前值复制给参数num。而在这个函数内部，又创建了并返回了一个可以访问num的闭包。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhang Yin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZY">
      <meta itemprop="description" content="zoeee">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZY">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/18/" class="post-title-link" itemprop="url">js高级程序设计第八天</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-18 18:22:44" itemprop="dateCreated datePublished" datetime="2020-04-18T18:22:44+08:00">2020-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-28 19:34:49" itemprop="dateModified" datetime="2020-04-28T19:34:49+08:00">2020-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Js/" itemprop="url" rel="index"><span itemprop="name">Js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function functionName(arg0,arg1,arg2)&#123;</span><br><span class="line">  //函数体</span><br><span class="line">  alert(functionName.name);//&quot;functionName&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个name是一个只读属性</p>
</blockquote>
<h3 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h3><p>在执行代码前会先读取函数声明，这意味着可以把函数声明放在调用它的语句后面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line">function sayHi()&#123;</span><br><span class="line">  alert(&quot;hi&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种创建函数的方式是使用函数表达式。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="title function_">fucntion</span>(<span class="params">args</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个函数并将它赋值给变量functionName,这种函数为匿名函数，因为function关键字的后面没有标识符。匿名函数的name属性为空字符串。并且使用前必须先赋值。</p>
<h3 id="函数声明与函数表达式之间的区别"><a href="#函数声明与函数表达式之间的区别" class="headerlink" title="函数声明与函数表达式之间的区别"></a>函数声明与函数表达式之间的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//不要这么写</span><br><span class="line">if(condition)&#123;</span><br><span class="line">  function sayHi()&#123;</span><br><span class="line">    alert(&quot;hi&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">   function sayHi()&#123;</span><br><span class="line">    alert(&quot;yo&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS引擎会尝试修复以上代码的错误，将其转化为合理的状态。<br>大多数浏览器会返回第二个结果，firefox会返回第一个结果。<br>不过如果使用函数表达式的话就没有问题了。此外创建函数并赋值返回，能够吧函数作为其他函数的值返回。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//通过名字调用自身即为递归函数</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">  if(num &lt;= 1 )&#123;</span><br><span class="line">    return 1 ;</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    return num * factorial(num-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">var anOtherFactorial = factorial;</span><br><span class="line">factorial = null ;</span><br><span class="line">alert(anOtherFactorial(4));//error:factorial is not a function</span><br></pre></td></tr></table></figure>
<p>将factorial变为null，在anOtherFactorial中调用的其实是null，所以会报错。<strong>这个时候我们可以用arguments.callee来解决问题（指向正在执行的函数的指针）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">  if(num &lt;= 1 )&#123;</span><br><span class="line">    return 1 ;</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    return num * arguments.callee(num-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>严格模式下，不能通过脚本访问arguments.callee，访问就会导致错误。不过，<strong>可以使用命名函数表达式来达成同样的效果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var factorial = (function f(num)&#123;</span><br><span class="line">  if(num &lt;= 1 )&#123;</span><br><span class="line">    return 1 ;</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    return num * f(num-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个名为f()的命名函数表达式。即使把函数赋值给了另一个变量，函数的名字f依然有效。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhang Yin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZY">
      <meta itemprop="description" content="zoeee">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZY">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/18/" class="post-title-link" itemprop="url">js高级程序设计第七天</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-18 17:22:44" itemprop="dateCreated datePublished" datetime="2020-04-18T17:22:44+08:00">2020-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-28 19:34:46" itemprop="dateModified" datetime="2020-04-28T19:34:46+08:00">2020-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Js/" itemprop="url" rel="index"><span itemprop="name">Js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>有一种借用构造函数的技术（也被叫做伪造对象或者经典继承）。这种技术的基本思想相当简单，即在子类型构造函数内部调用超类型构造函数。<br><strong>函数只不过是在特定环境中执行代码的对象。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">  this.nums = [1,2,3];</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">  //继承SuperType</span><br><span class="line">  SuperType.call(this);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.nums.push(4);</span><br><span class="line">alert(instance1.nums);//1,2,3,4</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance1.nums);//1,2,3</span><br></pre></td></tr></table></figure>
<p>这段代码中，每个子类的实例将拥有属于自己的属性。<br>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">  //继承了SuperType 同时传递了参数</span><br><span class="line">  SuperType.call(this,&quot;zy&quot;);</span><br><span class="line"></span><br><span class="line">  this.age = 100;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.name);//zy</span><br><span class="line">alert(instance.age);//100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问题：无法避免构造函数模式存在的问题——方法都在构造函数内部定义。</p>
</blockquote>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>有时也叫伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，发挥二者之长。背后的思路是<strong>使用原型链实现队原型属性和方法的继承，使用借用构造函数实现对实例属性的继承。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">  this.name = name ;</span><br><span class="line">  this.nums = [1,2,3];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">  //继承属性</span><br><span class="line">  SuperType.call(this,name);</span><br><span class="line"></span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">//继承方法</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">  alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">//第一个实例</span><br><span class="line">var instance1 = new SubType(&quot;zy&quot;,100);</span><br><span class="line">instance1.nums.push(4);</span><br><span class="line">alert(instacne1.nums)//1,2,3,4</span><br><span class="line">instance1.sayName();//zy</span><br><span class="line">instacne1.sayAge();//100</span><br><span class="line">//第二个实例</span><br><span class="line">var instance2 = new SubType(&quot;zoe&quot;,1);</span><br><span class="line">instance2.sayName();//zoe</span><br><span class="line">instacne2.sayAge();//1</span><br></pre></td></tr></table></figure>

<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>没有使用严格意义上的构造函数，而是借助原型可以基于已有的对象创建新对象，同时还不必因下次创建自定义类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function object(o)&#123;</span><br><span class="line">  function F()&#123;&#125;;</span><br><span class="line">  F.prototype = o ;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在object函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。<br>ES5中新增了Object.create来规范化原型式继承。这个方法接受两个参数：</p>
<ul>
<li>一个用作新对象原型的对象</li>
<li>（可选）为新对象定义额外属性的对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name : &quot;zy&quot;,</span><br><span class="line">  nums : [1,2,3]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = Object.create(person);</span><br><span class="line">anotherPerson.name = &quot;zyy&quot;;</span><br><span class="line">anotherPerson.nums.push(4);</span><br><span class="line"></span><br><span class="line">var yetAnotherPerson = Object.create(person);</span><br><span class="line">yetAnotherPerson.name = &quot;zyyy&quot;;</span><br><span class="line">yetAnotherPerson.nums.push(5);</span><br><span class="line"></span><br><span class="line">alert(person.nums)//1,2,3,4,5</span><br><span class="line">alert(person.name)//zy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二个参数中的属性会覆盖原型对象上的同名属性。</p>
</blockquote>
</li>
</ul>
<p>在没有必要兴师动众地创建构造函数，而只是想让一个对象与另一个对象保持类似的情况下，原型式继承是可以胜任的。但是包含引用类型值的属性始终会共享相应的值，就像原型模式一样。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像是真的完成了所有工作一样返回对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">  //通过调用函数来创建一个新对象</span><br><span class="line">  var clone = Object(original);</span><br><span class="line">  //以某种方式增强这个对象</span><br><span class="line">  clone.sayHi = function()&#123;</span><br><span class="line">    alert(&quot;hi&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name : &quot;zy&quot;,</span><br><span class="line">  nums : [1,2,3,4]</span><br><span class="line">&#125;</span><br><span class="line">var anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();//hi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。但会由于不能做到函数复用而降低效率。</p>
</blockquote>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>先看一下组合式继承的不足：无论在什么情况下，都会调用两次超类型构造函数：</p>
<ul>
<li>在创建子类型原型的时候</li>
<li>在子类型构造函数内部<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.nums = [1,2,3]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">  SuperType.call(this,name);//第二次调用</span><br><span class="line"></span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;)</span><br><span class="line">SubType.prototype = new SuperType();//第一次调用</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">  alert(this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第一次调用SuperType构造函数时，SubType.prototype会得到两个属性：name和nums，它们都是SuperType的实例属性，只不过现在位于SubType原型中。</li>
<li>当调用SubType构造函数时，又会调用一次SuperType的构造函数，这一次又在新对象上创建了实例属性name和nums。  </li>
</ul>
<p>于是这两个属性就覆盖了原型中的两个同名属性。  就有两组name和nums属性，一组在实例上，一组在SubType的原型中。</p>
<hr>
<p>寄生组合式继承背后的基本思路是：<strong>不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非是超类型原型的一个副本而已。本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType,superType)&#123;</span><br><span class="line">  var prototype = Object(superType.prototype); //创建超类型原型的一个副本</span><br><span class="line">  prototype.constructor = subType;//为创建的副本提供constructor属性</span><br><span class="line">  subType.prototype = prototype;//将新创建的对象（副本）赋值给子类型的原型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SuperType(name)&#123;</span><br><span class="line">  this.name  = name ;</span><br><span class="line">  this.nums = [1,2,3];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">  SuperType.call(this,name);</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType,SuperTYpe);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">  alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>能正常使用instanceof 和 isPrototypeOf()</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhang Yin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZY">
      <meta itemprop="description" content="zoeee">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZY">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/18/" class="post-title-link" itemprop="url">js高级程序设计第六天</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-18 16:22:44" itemprop="dateCreated datePublished" datetime="2020-04-18T16:22:44+08:00">2020-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-28 19:34:43" itemprop="dateModified" datetime="2020-04-28T19:34:43+08:00">2020-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Js/" itemprop="url" rel="index"><span itemprop="name">Js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h2><blockquote>
<p>一般的OO语言中会有接口继承与实现继承。JS中无法实现接口继承。所以主要依靠原型链来实现的。</p>
</blockquote>
<h3 id="原型、构造函数、实例的关系。"><a href="#原型、构造函数、实例的关系。" class="headerlink" title="原型、构造函数、实例的关系。"></a>原型、构造函数、实例的关系。</h3><p><strong>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针</strong><br>实现原型链有一种基本模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">  this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">  return this.property;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">  this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">//继承了SuperType</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.getSubValue = function()&#123;</span><br><span class="line">  return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue());// true;</span><br><span class="line">alert(instance.constructor）；</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ƒ SuperType()&#123;</span><br><span class="line">  this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。在调用instance.getSuperValue()会经历三个搜索步骤：  </p>
<ol>
<li>搜索实例</li>
<li>搜索SubType.prototype</li>
<li>搜索SuperTpye.prototype<blockquote>
<p>此时要注意的是instance.constructor指向的是SuperType/这是因为SubType的原型指向了另一个对象——SuperType的原型，而这个原型对象的constructor指向的是SuperType。  </p>
</blockquote>
</li>
</ol>
<p>并且通过instanceof操作符和isPrototypeOf可以确定instance是Object、SuperType、SubType任何一个类型的实例。<br>Object、SuperType、SubType都是instance的原型。</p>
<h3 id="给原型添加方法的代码一定要放在替换原型语句之后。"><a href="#给原型添加方法的代码一定要放在替换原型语句之后。" class="headerlink" title="给原型添加方法的代码一定要放在替换原型语句之后。"></a>给原型添加方法的代码一定要放在替换原型语句之后。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">  this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">  return this.property;</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">  this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">//继承了SuperType</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">//添加新方法</span><br><span class="line">SubType.prototype.getSubValue = function()&#123;</span><br><span class="line">  return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">//重写超类中的方法</span><br><span class="line">SubType.prototype.getSuperValue = function()&#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue());//false</span><br></pre></td></tr></table></figure>
<p>这里SuperType实例的方法会返回true，但是SubType实例的方法会依据重写的方法返回值。<br><strong>不可使用对象字面量来创建原型方法</strong><br>不然就会重写原型链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">  this.property = true ;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">  return this.property;</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;</span><br><span class="line">  this.subproperty = false ;</span><br><span class="line">&#125;;</span><br><span class="line">//继承了SuperType</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">//使用字面量添加新方法，会导致上一行代码无效</span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">  getSubValue : function()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">  &#125;,</span><br><span class="line">  someOtherMethod : function()&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">alert(instance.getSuperValue());// error</span><br><span class="line">//报错信息：instance.getSuperValue is not a function</span><br></pre></td></tr></table></figure>
<p>现在的原型包含的是一个Object的实例，而非SuperType的实例，所以原型链被切断。</p>
<h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><ol>
<li><p>最主要的问题来自包含引用类型值的原型。在通过原型实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章的变成了现在的原型属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">  this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;;</span><br><span class="line">function SubType()&#123;&#125;;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors) // [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;]</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.colors) // [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;]</span><br></pre></td></tr></table></figure>
<p>这里与之前的问题一样，由于引用类型是相同的，不同的实例修改该属性会导致同一值的变化，这是不符合我们预期要求的。</p>
</li>
<li><p>在创建子类型的实例时，不能像超类型的构造函数中传递参数。所以实践中很少用到原型链。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhang Yin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZY">
      <meta itemprop="description" content="zoeee">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZY">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/18/" class="post-title-link" itemprop="url">js高级程序设计第五天</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-18 15:22:44" itemprop="dateCreated datePublished" datetime="2020-04-18T15:22:44+08:00">2020-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-28 19:34:40" itemprop="dateModified" datetime="2020-04-28T19:34:40+08:00">2020-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Js/" itemprop="url" rel="index"><span itemprop="name">Js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p><strong>创建自定义类型的最常见方式，就是组合使用构造函数模式和原型模式。</strong></p>
<ol>
<li>构造函数模式用于定义实例属性</li>
<li>原型模式用于定义方法和共享的属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">  this.name = name ;</span><br><span class="line">  this.friends = [&quot;aaa&quot;,&quot;bbb&quot;];</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor : Person ,</span><br><span class="line">  sayName : function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person(&quot;1&quot;);</span><br><span class="line">var person2 = new Person(&quot;2&quot;);</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;ccc&quot;);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);//&quot;aaa,bbb,ccc&quot;</span><br><span class="line">alert(person2.friends);//&quot;aaa,bbb&quot;</span><br><span class="line">alert(person1.friends === person2.friends);//false</span><br><span class="line">alert(person1.sayName === person2.sayName);//true</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>把所有信息封装在了构造函数中，而通过在构造函数中初始化原型（必要情况下），又保持了同时使用构造函数和原型的有点。换句话说，可以通过<strong>检查某个应该存在的方法是否有效，来决定是否需要初始化原型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">  //属性</span><br><span class="line">  this.name = name ;</span><br><span class="line">  this.age = age ;</span><br><span class="line">  //方法</span><br><span class="line">  if (typeof this.sayName != &quot;function&quot;)&#123;</span><br><span class="line">    Person.prototype.sayName = function()&#123;</span><br><span class="line">      alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用instanceof 操作符来确定它的类型。</p>
</blockquote>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>在前几种模式不适用的情况下，可以用寄生构造函数模式。这种模式的基本思想是<strong>创建一个函数，该函数的作用仅仅是封装创建代码的对象，然后再返回新创建的对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name , age)&#123;</span><br><span class="line">  var o = new Object();</span><br><span class="line">  o.name = name ;</span><br><span class="line">  o.age = age ;</span><br><span class="line">  o.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  return o ;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person(&quot;zy&quot;,100);</span><br><span class="line">friend.sayName();//zy</span><br></pre></td></tr></table></figure>
<p><strong>构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。</strong>   </p>
<p>例如：需要创建一个具有额外方法的特殊数组对象，但是我们不能直接修改Array构造函数。</p>
<blockquote>
<p>由于返回的对象与构造函数或者与构造函数的原型属性没有关系，所以不能用instanceof 操作符来确定对象类型。</p>
</blockquote>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合用在一些安全的环境（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。<br>稳妥构造函数与寄生构造函数类似，但有两点不同：</p>
<ul>
<li>新创建的对象的实例方法不引用this</li>
<li>不适用new操作符调用构造函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">  //创建要返回的对象</span><br><span class="line">  var o = new Object();</span><br><span class="line">  //可以在这里定义私有变量和函数</span><br><span class="line">  </span><br><span class="line">  //添加方法 </span><br><span class="line">  o.sayName = function()&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">  //返回对象</span><br><span class="line">  return o ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var friend = Person(&quot;zy&quot;,100);</span><br><span class="line">friend.sayName();//zy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这样变量friend种保存的是一个稳妥对象，而除了调用sayName方法外，没有别的方式可以访问到其数据成员，计师有其他代码会给这个对象添加方法或者数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。这种安全性使得它非常适合在某些安全执行环境中使用。</p>
</blockquote>
</li>
</ul>
<p>与寄生构造函数类似，用instanceof 操作符对这种对象也没有什么意义。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zhang Yin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZY">
      <meta itemprop="description" content="zoeee">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ZY">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/18/" class="post-title-link" itemprop="url">js高级程序设计第四天</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-18 14:22:44" itemprop="dateCreated datePublished" datetime="2020-04-18T14:22:44+08:00">2020-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-04-28 19:34:37" itemprop="dateModified" datetime="2020-04-28T19:34:37+08:00">2020-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Js/" itemprop="url" rel="index"><span itemprop="name">Js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="构造函数生成对象的问题"><a href="#构造函数生成对象的问题" class="headerlink" title="构造函数生成对象的问题"></a>构造函数生成对象的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">  this.name = name ;</span><br><span class="line">  this.age = age ;</span><br><span class="line">  this.sayName = new Function(&quot;alert(this.name)&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但这样会有一个问题，创建两个Person类的实例person1和person2，它们两个会生成两个sayName方法，即使这个sayName方法本质上一模一样。<br><strong>解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">  this.name = name ;</span><br><span class="line">  this.age = age ;</span><br><span class="line">  this.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line">function sayName()&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在外部给出方法的实现，可以解决两个函数做同一件事的问题，但是却失去了封装的意义。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。prototype就是通过调用构造函数而创建的那个对象实例的原型对象。好处是可以让所有对象实例共享它所包含的属性和方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;;</span><br><span class="line">Person.prototype.name = &quot;zy&quot;;</span><br><span class="line">Person.prototype.sex = &quot;male&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><p><strong>1.无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。</strong><br><strong>2.创建了自定义的构造函数后，其原型对象默认指挥取得constructor属性；值与其他方法都是从Object继承而来。</strong><br><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=329834647,3252098432&fm=26&gp=0.jpg" alt="图解"></p>
<h3 id="更简单的原型方法"><a href="#更简单的原型方法" class="headerlink" title="更简单的原型方法"></a>更简单的原型方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor : Person,//注</span><br><span class="line">  name : &quot;zy&quot;,</span><br><span class="line">  sayName : function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>此处如果不加该行代码，则该prototype的constructor将指向由我们覆盖的Object对象，而不是Person对象。</li>
<li>此处自己覆写的constructor对象将从不可枚举的属性变成可枚举的属性。</li>
</ol>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><p>原型模式也不是没有缺点。</p>
<ol>
<li>省略了为构造函数传递初始化参数这一环节。</li>
<li>共享的本性。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor : Person ,</span><br><span class="line">  name : &quot;zy&quot;,</span><br><span class="line">  friends:[&quot;aaa&quot;,&quot;bbb&quot;],</span><br><span class="line">  sayName : function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;ccc&quot;);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);//&quot;aaa,bbb,ccc&quot;</span><br><span class="line">alert(person2.friends);//&quot;aaa,bbb,ccc&quot;</span><br><span class="line">alert(person1.friends === person2.friends);//true</span><br></pre></td></tr></table></figure>
结果反应修改一个实例的属性会导致另一个实例属性的改变，这不符合我们的一般认识。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Yin</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"./live2d_models/haruna/33/model.2017.tomo-bukatsu.low.json"},"display":{"superSample":2,"width":250,"height":400,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":false},"react":{"opacityDefault":0.5,"opacityOnHover":0},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
